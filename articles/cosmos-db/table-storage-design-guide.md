---
title: 設計 Azure Cosmos DB 資料表以進行調整和效能
description: Azure 資料表儲存體設計指南： Azure Cosmos DB 和 Azure 資料表儲存體中可調整且高效能的資料表
ms.service: cosmos-db
ms.subservice: cosmosdb-table
ms.topic: conceptual
ms.date: 05/21/2019
author: wmengmsft
ms.author: wmeng
ms.custom: seodec18
ms.openlocfilehash: 74bd22de81e385a4fbd9129a70616e24b594b0b4
ms.sourcegitcommit: f4f626d6e92174086c530ed9bf3ccbe058639081
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/25/2019
ms.locfileid: "75441326"
---
# <a name="azure-table-storage-table-design-guide-scalable-and-performant-tables"></a>Azure 資料表儲存體資料表設計指南：可擴充且高效能的資料表

[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

若要設計可擴充且高效能的資料表，您必須考慮各種因素，包括成本。 如果您先前已設計關係資料庫的架構，您就會熟悉這些考慮。 但是，雖然 Azure 資料表儲存體與關聯式模型之間有一些相似之處，但也有許多重要的差異。 這些差異通常會導致不同的設計，可能會對熟悉關係資料庫的人呈現直覺或錯誤，但如果您設計的是 NoSQL 索引鍵/值存放區（例如資料表儲存體），這就很有意義。

資料表儲存體是設計用來支援雲端規模的應用程式，其中可包含數十億個實體（關係資料庫術語中的「資料列」），或是必須支援高交易量的資料集。 因此，您必須以不同的方式思考如何儲存資料，並瞭解表格儲存體的運作方式。 設計良好的 NoSQL 資料存放區可讓您的解決方案更進一步（且成本較低），而不是使用關係資料庫的解決方案。 本指南針對這些主題為您提供協助。  

## <a name="about-azure-table-storage"></a>關於 Azure 資料表儲存體
本節將重點放在資料表儲存體的一些主要功能，特別與設計效能和擴充性有關。 如果您是 Azure 儲存體和資料表儲存體的新手，請參閱本文的其餘部分，[以瞭解 Microsoft Azure 儲存體的簡介](../storage/common/storage-introduction.md)，並[使用 .Net 開始使用 Azure 資料表儲存體](table-storage-how-to-use-dotnet.md)。 雖然本指南的焦點是在資料表儲存體上，但它確實包含 Azure 佇列儲存體和 Azure Blob 儲存體的一些討論，以及如何在解決方案中搭配資料表儲存體使用它們。  

資料表儲存體會使用表格式格式來儲存資料。 在標準術語中，資料表的每個資料列都代表一個實體，而資料行儲存該實體的各種屬性。 每個實體都有一組索引鍵來唯一識別它，而資料表儲存體會使用此時間戳記資料行來追蹤實體上次更新的時間。 [時間戳記] 欄位會自動新增，而且您無法手動以任意值覆寫時間戳記。 資料表儲存體使用這個上次修改的時間戳記（LMT）來管理開放式平行存取。  

> [!NOTE]
> 資料表儲存體 REST API 作業也會傳回其衍生自 LMT 的 `ETag` 值。 在本檔中，ETag 和 LMT 等詞彙會交換使用，因為它們會參考相同的基礎資料。  
> 
> 

下列範例說明簡單的資料表設計，用以儲存員工和部門的實體。 本指南稍後說明的許多範例皆以這個簡單的設計為基礎。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>時間戳記</th>
<th></th>
</tr>
<tr>
<td>Dynamics 365</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Dynamics 365</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>六月</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Dynamics 365</td>
<td>department</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Dynamics 365</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>銷售專線</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


到目前為止，這項設計看起來類似關係資料庫中的資料表。 主要差異在於必要資料行，以及在相同資料表中儲存多個實體類型的能力。 此外，每個使用者定義的屬性（例如**FirstName**或**Age**）都具有資料類型，例如整數或字串，就像關係資料庫中的資料行一樣。 不過，不像在關係資料庫中，資料表儲存體的無架構本質表示屬性在每個實體上不需要有相同的資料類型。 若要將複雜資料類型儲存在單一屬性中，您必須使用序列化格式，例如 JSON 或 XML。 如需詳細資訊，請參閱[瞭解資料表儲存體資料模型](https://msdn.microsoft.com/library/azure/dd179338.aspx)。

您選擇的 `PartitionKey` 和 `RowKey` 是良好資料表設計的基礎。 儲存在資料表中的每個實體都必須具有 `PartitionKey` 和 `RowKey`的唯一組合。 如同關係資料庫資料表中的索引鍵，`PartitionKey` 和 `RowKey` 的值會編制索引，以建立可快速查閱的叢集索引。 不過，資料表儲存體不會建立任何次要索引，因此這些是唯一的兩個索引屬性（稍後描述的一些模式會顯示如何解決這種明顯的限制）。  

資料表是由一或多個資料分割所組成，而您所做的許多設計決策都將圍繞于選擇適當的 `PartitionKey`，並 `RowKey` 優化您的解決方案。 解決方案只能包含一個資料表，其中包含組織成資料分割的所有實體，但是方案通常會有多個資料表。 資料表可協助您以邏輯方式組織您的實體，並協助您使用存取控制清單來管理資料的存取權。 您可以使用單一儲存體作業來卸載整個資料表。  

### <a name="table-partitions"></a>表格分割區
帳戶名稱、資料表名稱和 `PartitionKey` 會一起識別儲存體服務中的資料分割，其中資料表儲存體會儲存實體。 此外，分割區是實體的定址配置的一部分，可定義交易的範圍（請參閱本文稍後的「[實體群組交易](#entity-group-transactions)」一節），並形成資料表儲存體如何調整的基礎。 如需資料表資料分割的詳細資訊，請參閱[資料表儲存體的效能和擴充性檢查清單](../storage/tables/storage-performance-checklist.md)。  

在資料表儲存體中，個別節點會服務一或多個完整的資料分割，而服務會以動態方式跨節點平衡資料分割來進行調整。 如果節點處於負載中，資料表儲存體可以將該節點所服務的分割區範圍分割到不同的節點。 當流量 contosoconcerthall 時，表格儲存體可以將資料分割範圍從無訊息節點合併回單一節點。  

如需資料表儲存體之內部詳細資料的詳細資訊，尤其是它管理資料分割的方式，請參閱[Microsoft Azure 儲存體：具有強式一致性的高可用性雲端儲存體服務](https://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)。  

### <a name="entity-group-transactions"></a>實體群組交易
在資料表儲存體中，實體群組交易（Egt）是唯一的內建機制，可跨多個實體執行不可部分完成的更新。 Egt 也稱為*批次交易*。 Egt 只能對儲存在相同資料分割中的實體（在特定資料表中共用相同的分割區索引鍵）進行操作，因此每當您需要跨多個實體的不可部分完成交易行為時，請確定這些實體位於相同的資料分割中。 這通常是在相同資料表（和資料分割）中保留多個實體類型，而不是針對不同的實體類型使用多個資料表的原因。 單一 EGT 最多可以操作 100 個實體。  如果您提交多個並行 Egt 進行處理，請務必確保這些 Egt 不會在 Egt 間通用的實體上運作。 否則，您會有延遲處理的風險。

EGT 也會帶來需在您設計中評估的潛在取捨。 使用更多的分割區會增加應用程式的擴充性，因為 Azure 有更多機會在節點之間進行負載平衡要求。 但這可能會限制您的應用程式執行不可部分完成交易的能力，並維護資料的強式一致性。 此外，還有些在分割層級上的特定延展性目標，可能會限制單一節點的預期交易輸送量。

如需 Azure 儲存體帳戶的擴充性目標的詳細資訊，請參閱[標準儲存體帳戶的擴充性目標](../storage/common/scalability-targets-standard-account.md)。 如需資料表儲存體之擴充性目標的詳細資訊，請參閱[資料表儲存體的擴充性和效能目標](../storage/tables/scalability-targets.md)。 本指南後續幾節將討論各種設計策略，以協助您管理這類的權衡，並討論如何根據您用戶端應用程式的特定需求，選擇您的資料分割索引鍵。  

### <a name="capacity-considerations"></a>容量考量
下表包含當您在設計資料表儲存體解決方案時要注意的一些索引鍵值：  

| Azure 儲存體帳戶的容量總計 | 500 TB |
| --- | --- |
| Azure 儲存體帳戶中的資料表數目 |僅受限於儲存體帳戶的容量。 |
| 資料表中的資料分割數目 |僅受限於儲存體帳戶的容量。 |
| 資料分割中的實體數目 |僅受限於儲存體帳戶的容量。 |
| 個別實體的大小 |最多 1 MB，最多255個屬性（包括 `PartitionKey`、`RowKey`和 `Timestamp`）。 |
| `PartitionKey` 的大小 |大小上限為 1 KB 的字串。 |
| `RowKey` 的大小 |大小上限為 1 KB 的字串。 |
| 實體群組交易的大小 |交易最多可包含100個實體，而承載的大小必須小於 4 MB。 一個 EGT 只能更新實體一次。 |

如需詳細資訊，請參閱[瞭解表格服務資料模型](https://msdn.microsoft.com/library/azure/dd179338.aspx)。  

### <a name="cost-considerations"></a>成本考量
資料表儲存體相對較便宜，但您應該在評估使用資料表儲存體的任何解決方案時，包含容量使用量和交易數量的成本預估。 不過，在許多情況下，儲存反正規化或重複的資料以改善方案的效能或擴充性，是有效的方法。 如需定價的詳細資訊，請參閱 [Azure 儲存體定價](https://azure.microsoft.com/pricing/details/storage/)。  

## <a name="guidelines-for-table-design"></a>資料表設計指導方針
這些清單摘要說明當您在設計資料表時，應牢記在心的一些重要指導方針。 本指南稍後會更詳細地解決這些問題。 這些方針與您在關係資料庫設計中一般遵循的指導方針不同。  

設計您的資料表儲存體以獲得更高的*讀取*效率：

* **設計大量讀取應用程式中的查詢。** 當您要設計資料表時，請考慮您在考慮如何更新實體之前，會執行的查詢（尤其是延遲敏感的查詢）。 透過這樣的方式，通常可造就一個有效率且高效能的解決方案。  
* **在查詢中同時指定 `PartitionKey` 和 `RowKey`。** 這類*查詢*是最有效率的資料表儲存體查詢。  
* **考慮儲存重複的實體副本。** 資料表儲存體的成本較低，因此請考慮多次儲存相同的實體（使用不同的索引鍵），以啟用更有效率的查詢。  
* **考慮將資料反正規化。** 資料表儲存體的成本較低，因此請考慮反正規化您的資料。 例如儲存摘要實體，可讓彙總資料的查詢只需存取單一實體。  
* **使用複合索引鍵值。** 您擁有的唯一金鑰是 `PartitionKey` 和 `RowKey`。 例如，使用複合索引鍵值啟用替代的實體索引鍵式存取路徑。  
* **使用查詢預測。** 使用僅選取您所需欄位的查詢，即可減少透過網路傳輸的資料量。  

將您的資料表儲存體設計成有效率的*撰寫*：  

* **不要建立熱分割區。** 選擇可讓您在任何時間點，將要求分散到多個分割上的索引鍵。  
* **避免流量尖峰。** 在合理的時間內散佈流量，並避免流量尖峰。
* **不一定要為每個實體的類型建立個別的資料表。** 需要跨實體類型執行不可部分完成的交易時，您可以在相同資料表的相同分割中儲存多個實體類型。
* **考慮必須達到的最大輸送量。** 您必須留意資料表儲存體的擴充性目標，並確保您的設計不會使其超出。  

稍後在本指南中，您將會看到將所有這些原則納入實務的範例。  

## <a name="design-for-querying"></a>查詢的設計
資料表儲存體可能是讀取密集型、大量寫入或兩者混合。 本節會考慮設計以有效率地支援讀取作業。 一般而言，支援有效讀取作業的設計，也可兼顧寫入作業的效率。 不過，設計支援寫入作業時，還有其他考慮。 下一節將討論[資料修改的設計](#design-for-data-modification)。

有一個好的起點可以讓您有效率地讀取資料，就是詢問「我的應用程式需要執行哪些查詢才能取得所需的資料？」  

> [!NOTE]
> 使用資料表儲存體時，請務必事先修正設計，因為在稍後變更它很難且昂貴。 例如，在關係資料庫中，通常只要將索引加入至現有的資料庫，就可以解決效能問題。 這不是資料表儲存體的選項。  

### <a name="how-your-choice-of-partitionkey-and-rowkey-affects-query-performance"></a>您選擇的 `PartitionKey` 和 `RowKey` 如何影響查詢效能
下列範例假設資料表儲存體會使用下列結構來儲存員工實體（大部分的範例會省略 `Timestamp` 屬性）：  

| 資料行名稱 | Data type |
| --- | --- |
| `PartitionKey` （部門名稱） |String |
| `RowKey` （員工識別碼） |String |
| `FirstName` |String |
| `LastName` |String |
| `Age` |整數 |
| `EmailAddress` |String |

以下是設計資料表儲存體查詢的一些一般指導方針。 下列範例中使用的篩選語法來自于資料表儲存體 REST API。 如需詳細資訊，請參閱[查詢實體](https://msdn.microsoft.com/library/azure/dd179421.aspx)。  

* *點查詢*是使用最有效率的查閱，建議用於高容量查閱或需要最低延遲的查閱。 這類查詢可以使用索引來有效率地找出個別實體，方法是同時指定 `PartitionKey` 和 `RowKey` 值。 例如： `$filter=(PartitionKey eq 'Sales') and (RowKey eq '2')` 。  
* 第二個最佳做法是*範圍查詢*。 它會使用 `PartitionKey`，並篩選 `RowKey` 值的範圍，以傳回一個以上的實體。 `PartitionKey` 值會識別特定的分割區，而 `RowKey` 值則識別該資料分割中的實體子集。 例如： `$filter=PartitionKey eq 'Sales' and RowKey ge 'S' and RowKey lt 'T'` 。  
* 第三個最佳做法是資料*分割掃描*。 它會使用 `PartitionKey`，並篩選另一個非索引鍵屬性，而且可能會傳回多個實體。 `PartitionKey` 值會識別特定的資料分割，而屬性值則會針對該資料分割中的實體子集進行選取。 例如： `$filter=PartitionKey eq 'Sales' and LastName eq 'Smith'` 。  
* *資料表掃描*不會包含 `PartitionKey`，而且效率不佳，因為它會搜尋組成資料表的所有分割區，以尋找任何相符的實體。 無論您的篩選器是否使用 `RowKey`，它都會執行資料表掃描。 例如： `$filter=LastName eq 'Jones'` 。  
* 傳回多個實體的 Azure 資料表儲存體查詢會以 `PartitionKey` 和 `RowKey` 順序排序它們。 若要避免在用戶端中使用實體，請選擇定義最常見排序次序的 `RowKey`。 Azure 資料表 API 在 Azure Cosmos DB 中傳回的查詢結果不會依資料分割索引鍵或資料列索引鍵排序。 如需詳細的功能差異清單，請參閱 [Azure Cosmos DB 和 Azure 資料表儲存體中資料表 API 之間的差異](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)。

使用 "**or**" 指定以 `RowKey` 值為基礎的篩選會產生資料分割掃描，而不會被視為範圍查詢。 因此，請避免使用篩選準則的查詢，例如： `$filter=PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322')`。  

如需使用儲存體用戶端程式庫執行有效率查詢的用戶端程式代碼範例，請參閱：  

* [使用儲存體用戶端程式庫執行點查詢](#run-a-point-query-by-using-the-storage-client-library)
* [使用 LINQ 取出多個實體](#retrieve-multiple-entities-by-using-linq)
* [伺服器端預測](#server-side-projection)  

如需可對儲存在相同資料表中的多個實體類型進行處理的用戶端程式碼範例，請參閱：  

* [使用異質性實體類型](#work-with-heterogeneous-entity-types)  

### <a name="choose-an-appropriate-partitionkey"></a>選擇適當的 `PartitionKey`
您所選擇的 `PartitionKey` 應該在將實體分散到多個資料分割（以確保可調整的解決方案）的需求時，平衡是否需要使用 Egt （以確保一致性）。  

在一個極端的情況下，您可以將所有實體儲存在單一分割區中。 但這可能會限制您的解決方案的擴充性，而且會讓資料表儲存體無法達到負載平衡的要求。 另一方面，您可以為每個資料分割儲存一個實體。 這是可高度擴充的功能，可讓資料表儲存體對要求進行負載平衡，但可防止您使用實體群組交易。  

理想的 `PartitionKey` 可讓您使用有效率的查詢，而且具有足夠的資料分割，以確保您的解決方案可調整。 一般來說，您會發現您的實體會有適當的屬性，可將實體分散到足夠的資料分割。

> [!NOTE]
> 例如，在儲存使用者或員工相關資訊的系統中，`UserID` 可能是很好的 `PartitionKey`。 您可能會有數個使用特定 `UserID` 做為資料分割索引鍵的實體。 儲存使用者資料的每個實體都會分組成單一資料分割。 這些實體可以透過 Egt 存取，但仍可高度擴充。
> 
> 

您選擇的 `PartitionKey` 還有其他考慮，與您插入、更新和刪除實體的方式有關。 如需詳細資訊，請參閱本文稍後的[設計資料修改](#design-for-data-modification)。  

### <a name="optimize-queries-for-table-storage"></a>優化資料表儲存體的查詢
資料表儲存體會使用單一叢集索引中的 `PartitionKey` 和 `RowKey` 值，自動為您的實體編制索引。 這是點查詢最有效率的使用原因。 不過，`PartitionKey` 和 `RowKey`上的叢集索引不會有任何索引。

許多設計必須符合需求，才能讓您根據多個準則查閱實體。 例如，根據電子郵件、員工識別碼或姓氏來尋找員工實體。 [資料表設計模式](#table-design-patterns)一節中的下列模式會解決這些類型的需求。 這些模式也會描述如何解決資料表儲存體不提供次要索引的情況。  

* [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern)：使用不同的 `RowKey` 值（在相同的資料分割中），儲存每個實體的多個複本。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。  
* 資料[分割次要索引模式](#inter-partition-secondary-index-pattern)：使用不同的 `RowKey` 值儲存每個實體的多個複本，並在個別的資料分割或個別的資料表中。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。  
* [索引實體模式](#index-entities-pattern)：維護索引實體以啟用有效率的搜尋，以傳回實體清單。  

### <a name="sort-data-in-table-storage"></a>排序資料表儲存體中的資料

資料表儲存體會根據 `PartitionKey` 然後 `RowKey`，傳回以遞增順序排序的查詢結果。

> [!NOTE]
> Azure 資料表 API 在 Azure Cosmos DB 中傳回的查詢結果不會依資料分割索引鍵或資料列索引鍵排序。 如需詳細的功能差異清單，請參閱 [Azure Cosmos DB 和 Azure 資料表儲存體中資料表 API 之間的差異](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)。

資料表儲存體中的索引鍵是字串值。 為確保數值正確排序，您應該將它們轉換成固定長度，並以零填補。 例如，如果您用來做為 `RowKey` 的員工識別碼值是整數值，您應將員工識別碼**123**轉換為**00000123**。 

許多應用程式都需要使用以不同順序排序的資料：例如，依名稱或加入日期為員工排序。 [資料表設計模式](#table-design-patterns)一節中的下列模式可解決如何替代實體的排序次序：  

* [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern)：使用不同的 `RowKey` 值（在相同的資料分割中），儲存每個實體的多個複本。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。  
* 資料[分割次要索引模式](#inter-partition-secondary-index-pattern)：在不同的資料表中，使用不同的 `RowKey` 值，儲存每個實體的多個複本。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。
* [記錄結尾模式](#log-tail-pattern)：使用以反向的日期和時間順序排序的 `RowKey` 值，抓取最近新增至資料分割的*n*個實體。  

## <a name="design-for-data-modification"></a>資料修改的設計
本節著重於最佳化插入、更新和刪除的設計考量。 在某些情況下，您必須評估設計的取捨，以優化查詢以優化資料修改的設計。 這項評估與您在關係資料庫的設計中所做的一樣（雖然關係資料庫中的管理設計取捨的技巧不同）。 [資料表設計模式](#table-design-patterns)一節會說明資料表儲存體的一些詳細設計模式，並強調這些取捨。 在實務上，您會發現許多針對查詢實體而優化的設計，也適用于修改實體。  

### <a name="optimize-the-performance-of-insert-update-and-delete-operations"></a>最佳化插入、更新和刪除作業的效能
若要更新或刪除實體，您必須能夠使用 `PartitionKey` 和 `RowKey` 值來識別它。 在這方面，您選擇用來修改實體的 `PartitionKey` 和 `RowKey`，應該遵循您選擇支援點查詢的類似準則。 您想要盡可能有效率地識別實體。 您不想要使用無效率的資料分割或資料表掃描來尋找實體，以探索您需要更新或刪除的 `PartitionKey` 和 `RowKey` 值。  

[資料表設計模式](#table-design-patterns)一節中的下列模式會解決您的插入、更新和刪除作業的效能優化：  

* [大量刪除模式](#high-volume-delete-pattern)：藉由將所有要同時刪除的實體儲存在自己的個別資料表中，來啟用刪除大量實體的作業。 您可以藉由刪除資料表來刪除實體。  
* [資料序列模式](#data-series-pattern)：將完整資料序列儲存在單一實體中，以將您提出的要求數目降至最低。  
* [寬型實體模式](#wide-entities-pattern)：使用多個實體實體來儲存具有超過252屬性的邏輯實體。  
* [大型實體模式](#large-entities-pattern)：使用 blob 儲存體來儲存大型屬性值。  

### <a name="ensure-consistency-in-your-stored-entities"></a>確保預存實體中的一致性
另一個會在您選擇最佳化資料修改的索引鍵時造成影響的主要因素，是如何使用不可部分完成的交易確保一致性。 只有對於儲存在相同資料分割中的實體，才能使用 EGT 來運作。  

[資料表設計模式](#table-design-patterns)一節中的下列模式會解決管理一致性：  

* [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern)：使用不同的 `RowKey` 值（在相同的資料分割中），儲存每個實體的多個複本。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。  
* 資料[分割次要索引模式](#inter-partition-secondary-index-pattern)：使用不同的 `RowKey` 值儲存每個實體的多個複本，並在個別的資料分割或個別的資料表中。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。  
* [最終一致的交易模式](#eventually-consistent-transactions-pattern)：使用 Azure 佇列，讓資料分割界限或儲存體系統界限之間最終一致的行為。
* [索引實體模式](#index-entities-pattern)：維護索引實體以啟用有效率的搜尋，以傳回實體清單。  
* 反正規化[模式](#denormalization-pattern)：將相關資料結合在單一實體中，讓您使用單一點查詢來抓取所有需要的資料。  
* [資料序列模式](#data-series-pattern)：將完整資料序列儲存在單一實體中，以將您提出的要求數目降至最低。  

如需詳細資訊，請參閱本文稍後的[實體群組交易](#entity-group-transactions)。  

### <a name="ensure-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>確保您針對有效率的修改所做的設計有助於提升查詢效率
在許多情況下，效率查詢的設計都可造就有效的修改，但是您務必要評估這對您的特定案例是否適用。 [資料表設計模式](#table-design-patterns)一節中的某些模式會在查詢和修改實體之間明確評估取捨，而且您應該一律考慮每種作業類型的數目。  

[資料表設計模式](#table-design-patterns)一節中的下列模式可解決設計有效率的查詢與設計有效率的資料修改之間的取捨：  

* [複合索引鍵模式](#compound-key-pattern)：使用複合 `RowKey` 值，讓用戶端使用單點查詢來查閱相關資料。  
* [記錄結尾模式](#log-tail-pattern)：使用以反向的日期和時間順序排序的 `RowKey` 值，抓取最近新增至資料分割的*n*個實體。  

## <a name="encrypt-table-data"></a>加密資料表資料
.NET Azure 儲存體用戶端程式庫支援對插入和取代作業進行字串實體屬性的加密。 加密的字串會以二進位屬性的形式儲存在服務上，並在解密後轉換回字串。    

針對資料表，除了加密原則之外，使用者必須指定要加密的屬性。 請指定 `EncryptProperty` 屬性（針對衍生自 `TableEntity`的 POCO 實體），或在要求選項中指定加密解析程式。 加密解析程式是一個委派，它會接受資料分割索引鍵、資料列索引鍵和屬性名稱，並傳回布林值，指出是否應該加密該屬性。 在加密期間，用戶端程式庫會使用此資訊來決定是否要在寫入網路時加密屬性。 委派也提供關於屬性如何加密的可能邏輯。 （例如，如果 X，則會加密屬性 A，否則會加密屬性 A 和 B）。讀取或查詢實體時不需要提供此資訊。

目前不支援合併。 因為先前可能已經使用不同的金鑰來加密屬性的子集，所以只要合併新的屬性並更新中繼資料，就會導致資料遺失。 合併可能需要進行額外的服務呼叫，才能從服務讀取預先存在的實體，或針對每個屬性使用新的索引鍵。 這兩者都不適用於效能考慮。     

如需加密資料表資料的詳細資訊，請參閱[Microsoft Azure 儲存體的用戶端加密和 Azure Key Vault](../storage/common/storage-client-side-encryption.md)。  

## <a name="model-relationships"></a>模型關聯性
建置網域模型是設計複雜系統時的關鍵步驟。 一般而言，您會使用模型化程式來識別實體及其之間的關聯性，以瞭解商務領域並通知您系統的設計。 本節著重于如何將網域模型中的一些常見關聯性類型轉譯為數據表儲存體的設計。 從邏輯資料模型對應至實體 NoSQL 架構資料模型的程式，與設計關係資料庫時所使用的程式不同。 關係資料庫設計通常會假設資料正規化程式已優化，可將冗余降至最低。 這種設計也會假設有一個宣告式查詢功能，可將資料庫的運作方式抽象化。  

### <a name="one-to-many-relationships"></a>一對多關聯性
商業網域物件之間常會產生一對多關聯性：例如，一個部門有許多員工。 有數種方式可在資料表儲存體中執行一對多關聯性，每個都有可能與特定案例相關的優缺點。  

假設有數萬個部門和員工實體的大型跨國公司的範例。 每個部門都有許多員工，而且每個員工都與一個特定部門相關聯。 其中一個方法是儲存個別的部門和員工實體，如下所示：  

![顯示部門實體和 employee 實體的圖形][1]

這個範例會根據 `PartitionKey` 值，顯示類型之間的隱含一對多關聯性。 每個部門可以有許多員工。  

此範例也說明相同資料分割中的部門實體及其相關聯的員工實體。 您可以選擇針對不同的實體類型使用不同的分割區、資料表或甚至儲存體帳戶。  

另一個替代方法是反正規化您的資料，並只儲存具有反正規化部門資料的員工實體，如下列範例所示。 在此特定案例中，如果您需要能夠變更部門經理的詳細資料，這種反正規化方法可能不是最佳作法。 若要這樣做，您必須更新部門中的每個員工。  

![Employee 實體的圖形][2]

如需詳細資訊，請參閱本指南下半部的 [去正規化模式](#denormalization-pattern) 。  

下表摘要說明用來儲存具有一對多關聯性之員工和部門實體的每個方法的優缺點。 您也應該考慮執行各種作業所需的頻率。 如果此作業只發生不常發生的情況，可能會有一個包含昂貴作業的設計。  

<table>
<tr>
<th>方法</th>
<th>優點</th>
<th>缺點</th>
</tr>
<tr>
<td>個別的實體類型、相同的資料分割、相同的資料表</td>
<td>
<ul>
<li>您可以使用單一作業更新部門實體。</li>
<li>如果您需要在每次更新/插入/刪除員工實體時修改部門實體，您可以使用 EGT 來維持一致性。 例如，假設您維護每個部門的部門員工計數。</li>
</ul>
</td>
<td>
<ul>
<li>您可能需要同時取得部分用戶端活動的員工和部門實體。</li>
<li>儲存作業會在相同資料分割中執行。 在交易量很高的情況下，這可能會導致作用點。</li>
<li>您無法使用 EGT 將員工移至新的部門。</li>
</ul>
</td>
</tr>
<tr>
<td>個別的實體類型、不同的資料分割或資料表或儲存體帳戶</td>
<td>
<ul>
<li>您可以使用單一作業更新部門實體或員工實體。</li>
<li>在交易量很高的情況下，這有助於將負載分散到更多的磁碟分割。</li>
</ul>
</td>
<td>
<ul>
<li>您可能需要同時取得部分用戶端活動的員工和部門實體。</li>
<li>當您更新/插入/刪除員工並更新部門時，您無法使用 Egt 來維持一致性。 例如，更新某個部門實體中的員工計數。</li>
<li>您無法使用 EGT 將員工移至新的部門。</li>
</ul>
</td>
</tr>
<tr>
<td>去正規化為單一實體類型</td>
<td>
<ul>
<li>您可以透過單一要求擷取您所需的所有資訊。</li>
</ul>
</td>
<td>
<ul>
<li>如果您需要更新部門資訊（這會要求您更新部門中的所有員工），維護一致性可能會很耗費資源。</li>
</ul>
</td>
</tr>
</table>

您在這些選項中的選擇，以及最重要的優點和缺點，取決於您的特定應用程式案例。 例如，您修改部門實體的頻率為何？ 您的所有員工查詢都需要額外的部門資訊嗎？ 您對資料分割或儲存體帳戶的擴充性限制有多接近？  

### <a name="one-to-one-relationships"></a>一對一關聯性
領域模型可以包含實體之間的一對一關聯性。 如果您需要在資料表儲存體中執行一對一關聯性，您也必須在需要同時取得兩者時，選擇如何連結兩個相關的實體。 此連結可以是隱含的（根據索引鍵值中的慣例）或明確的，方法是將連結的格式儲存為 `PartitionKey`，並將每個實體中 `RowKey` 值轉換為其相關的實體。 如需是否應將相關實體儲存於相同資料分割中的討論，請參閱 [一對多關聯性](#one-to-many-relationships)一節。  

另外還有一些可能會導致您在資料表儲存體中執行一對一關聯性的執行考慮：  

* 處理大型實體（如需詳細資訊，請參閱[大型實體模式](#large-entities-pattern)）。  
* 執行存取控制（如需詳細資訊，請參閱[使用共用存取簽章控制存取](#control-access-with-shared-access-signatures)）。  

### <a name="join-in-the-client"></a>用戶端中的聯結
雖然有方法可以在資料表儲存體中建立關聯性的模型，但別忘了使用資料表儲存體的兩個主要原因是擴充性和效能。 如果您發現模型化許多會危害解決方案效能和擴充性的關係，您應該詢問自己是否需要在資料表設計中建立所有資料關係。 如果您讓用戶端應用程式執行任何必要的聯結，您可能可以簡化設計，並改善方案的擴充性和效能。  

例如，如果您的小型資料表包含不常變更的資料，您可以一次取出此資料，並在用戶端上加以快取。 這可以避免重複擷取相同資料的往返。 在本指南所討論的範例中，小型組織中的一組部門可能會很小，而且不常變更。 這讓它成為用戶端應用程式可以下載一次並快取為查閱資料的資料的理想候選。  

### <a name="inheritance-relationships"></a>繼承關聯性
如果您的用戶端應用程式使用一組組成繼承關聯性的類別來代表商務實體，您可以輕鬆地將這些實體保存在資料表儲存體中。 例如，您可能會在用戶端應用程式中定義下列一組類別，其中 `Person` 是抽象類別。

![繼承關聯性圖表][3]

您可以使用單一 `Person` 資料表來保存資料表儲存體中兩個具體類別的實例。 使用如下所示的實體：  

![顯示 customer 實體和 employee 實體的圖形][4]

如需在用戶端程式代碼的相同資料表中使用多個實體類型的詳細資訊，請參閱本指南稍後的使用[異類實體類型](#work-with-heterogeneous-entity-types)。 其中提供如何在用戶端程式碼中辨識實體類型的範例。  

## <a name="table-design-patterns"></a>資料表設計模式
在先前的章節中，您已瞭解如何使用查詢來優化資料表的設計，並可用於插入、更新和刪除實體資料。 本節將說明適用于資料表儲存體的一些模式。 此外，您還會瞭解如何實際解決本指南先前所引發的一些問題和取捨。 下圖摘要說明不同模式之間的關聯性：  

![資料表設計模式的圖表][5]

模式圖會反白顯示本指南中記載的模式（藍色）與反模式（橙色）之間的一些關聯性。 當然還有許多其他模式也值得考量。 例如，資料表儲存體的其中一個主要案例是從[命令查詢責任隔離](https://msdn.microsoft.com/library/azure/jj554200.aspx)模式使用[具體化視圖模式](https://msdn.microsoft.com/library/azure/dn589782.aspx)。  

### <a name="intra-partition-secondary-index-pattern"></a>內部資料分割次要索引模式
使用不同的 `RowKey` 值（在相同的資料分割中），儲存每個實體的多個複本。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。 您可以使用 Egt，讓複本之間的更新保持一致。  

#### <a name="context-and-problem"></a>內容和問題
資料表儲存體會使用 `PartitionKey` 和 `RowKey` 值，自動編制實體的索引。 這可讓用戶端應用程式使用這些值有效率地抓取實體。 例如，使用下列資料表結構，用戶端應用程式可以使用點查詢來抓取個別員工實體，方法是使用部門名稱和員工識別碼（`PartitionKey` 和 `RowKey` 值）。 用戶端也可以擷取每個部門內以員工識別碼排序的實體。

![Employee 實體的圖形][6]

如果您也想要根據另一個屬性的值（例如電子郵件地址）尋找 employee 實體，您必須使用較不有效率的資料分割掃描來尋找相符專案。 這是因為資料表儲存體不提供次要索引。 此外，沒有任何選項可要求以與 `RowKey` 訂單不同的順序排序的員工清單。  

#### <a name="solution"></a>解決方案
若要解決缺少次要索引的情況，您可以儲存每個實體的多個複本，每個複本使用不同的 `RowKey` 值。 如果您儲存具有下列結構的實體，您可以根據電子郵件地址或員工識別碼有效率地抓取員工實體。 `RowKey`、`empid_`和 `email_` 的前置詞值，可讓您使用一系列的電子郵件地址或員工識別碼來查詢單一員工或某個範圍的員工。  

![顯示員工實體具有不同 RowKey 值的圖形][7]

下列兩個篩選準則（一個依員工識別碼查閱，另一個依電子郵件地址查閱）都會指定點查詢：  

* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') and (RowKey eq 'email_jonesj@contoso.com')  

如果您查詢某範圍的員工實體，您可以指定以員工識別碼順序排序的範圍，或以電子郵件地址順序排序的範圍。 在 `RowKey`中查詢具有適當前置詞的實體。  

* 若要尋找銷售部門中員工識別碼範圍介於000100到000199的所有員工，請使用： $filter = （PartitionKey eq ' Sales '）和（RowKey ge ' empid_000100 '）和（RowKey le ' empid_000199 '）  
* 若要使用開頭為字母 "a" 的電子郵件地址來尋找銷售部門中的所有員工，請使用： $filter = （PartitionKey eq ' Sales '）和（RowKey ge ' email_a '）和（RowKey lt ' email_b '）  
  
前述範例中使用的篩選語法來自于資料表儲存體 REST API。 如需詳細資訊，請參閱[查詢實體](https://msdn.microsoft.com/library/azure/dd179421.aspx)。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 資料表儲存體的使用量相對較低，因此儲存重復資料的成本負擔不應該是主要的考慮。 不過，您應該一律根據預期的儲存需求來評估您的設計成本，並只新增重複的實體以支援用戶端應用程式將執行的查詢。  
* 因為次要索引實體會儲存在與原始實體相同的資料分割中，所以請確定您不會超過個別資料分割的擴充性目標。  
* 您可以將重複實體彼此保持一致，方法是使用 EGT 自動更新實體的兩個複本。 這表示您應該將實體的所有複本儲存在相同的資料分割中。 如需詳細資訊，請參閱[使用實體群組交易](#entity-group-transactions)。  
* 針對每個實體，用於 `RowKey` 的值必須是唯一的。 請考慮使用複合索引鍵值。  
* 在 `RowKey` 中填補數值（例如，員工識別碼000223），可根據上限和下限來進行正確的排序和篩選。  
* 您不一定需要複製實體的所有屬性。 例如，如果在 `RowKey` 中使用電子郵件地址查閱實體的查詢永遠都不需要員工的年齡，這些實體可以有下列結構：

  ![Employee 實體的圖形][8]

* 一般來說，最好是儲存重複的資料，並確定您可以使用單一查詢來抓取所有需要的資料，而不是使用一個查詢來尋找實體，另一個則用來查閱所需的資料。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
使用此模式的時機包括：

- 您的用戶端應用程式需要使用各種不同的索引鍵來取得實體。
- 您的用戶端需要以不同的排序次序來取得實體。
- 您可以使用各種不同的唯一值來識別每個實體。

不過，當您使用不同的 `RowKey` 值來執行實體查閱時，請確定您不會超過資料分割的擴充性限制。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [間分割次要索引模式](#inter-partition-secondary-index-pattern)
* [複合索引鍵模式](#compound-key-pattern)
* [實體群組交易](#entity-group-transactions)
* [使用異質性實體類型](#work-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>間資料分割次要索引模式
使用不同的 `RowKey` 值，在不同的資料分割或不同的資料表中，儲存每個實體的多個複本。 這可讓您使用不同的 `RowKey` 值，快速且有效率地查閱和替代排序次序。  

#### <a name="context-and-problem"></a>內容和問題
資料表儲存體會使用 `PartitionKey` 和 `RowKey` 值，自動編制實體的索引。 這可讓用戶端應用程式使用這些值有效率地抓取實體。 例如，使用下列資料表結構，用戶端應用程式可以使用點查詢來抓取個別員工實體，方法是使用部門名稱和員工識別碼（`PartitionKey` 和 `RowKey` 值）。 用戶端也可以擷取每個部門內以員工識別碼排序的實體。  

![Employee 實體的圖形][9]

如果您也想能夠根據其他屬性 (例如電子郵件地址) 的值尋找員工實體，您必須使用效率較低的資料分割掃描來尋找相符項目。 這是因為資料表儲存體不提供次要索引。 此外，沒有任何選項可要求以與 `RowKey` 訂單不同的順序排序的員工清單。  

您預期這些實體會有大量的交易，而且想要將資料表儲存體速率限制用戶端的風險降到最低。  

#### <a name="solution"></a>解決方案
若要解決缺少次要索引的情況，您可以儲存每個實體的多個複本，每個複本都使用不同的 `PartitionKey` 和 `RowKey` 值。 如果您儲存具有下列結構的實體，您可以根據電子郵件地址或員工識別碼有效率地抓取員工實體。 `PartitionKey`、`empid_`和 `email_` 的前置詞值可讓您識別想要用於查詢的索引。  

![圖形：顯示具有主要索引的員工實體，以及具有次要索引的員工實體][10]

下列兩個篩選準則（一個依員工識別碼查閱，另一個依電子郵件地址查閱）都會指定點查詢：  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') and (RowKey eq 'jonesj@contoso.com')  

如果您查詢某範圍的員工實體，您可以指定以員工識別碼順序排序的範圍，或以電子郵件地址順序排序的範圍。 在 `RowKey`中查詢具有適當前置詞的實體。  

* 若要尋找銷售部門中員工識別碼在**000100**到**000199**範圍內的所有員工，以員工識別碼順序排序，請使用： $filter = （PartitionKey eq ' empid_Sales '）和（RowKey ge ' 000100 '）和（RowKey le ' 000199 '）  
* 若要尋找銷售部門中的所有員工，其電子郵件地址開頭為 "a"，以電子郵件地址順序排序，請使用： $filter = （PartitionKey eq ' email_Sales '）和（RowKey ge ' a '）和（RowKey lt ' b '）  

請注意，上述範例中使用的篩選語法來自于資料表儲存體 REST API。 如需詳細資訊，請參閱[查詢實體](https://msdn.microsoft.com/library/azure/dd179421.aspx)。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 您可以讓重複實體彼此之間始終保持一致，方法是使用 [最終一致的交易模式](#eventually-consistent-transactions-pattern) 來維護主要和次要索引實體。  
* 資料表儲存體的使用量相對較低，因此儲存重復資料的成本負擔不一定是主要的考慮。 不過，一律會根據預期的儲存需求來評估您的設計成本，並只新增重複的實體以支援用戶端應用程式將執行的查詢。  
* 針對每個實體，用於 `RowKey` 的值必須是唯一的。 請考慮使用複合索引鍵值。  
* 在 `RowKey` 中填補數值（例如，員工識別碼000223），可根據上限和下限來進行正確的排序和篩選。  
* 您不一定需要複製實體的所有屬性。 例如，如果在 `RowKey` 中使用電子郵件地址查閱實體的查詢永遠都不需要員工的年齡，這些實體可以有下列結構：
  
  ![顯示具有次要索引之 employee 實體的圖形][11]
* 一般來說，最好是儲存重複的資料，並確保您可以透過單一查詢抓取所有需要的資料，而不是使用一個查詢來尋找實體，方法是使用次要索引，另一個用來查閱主要索引中的必要資料。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
使用此模式的時機包括：

- 您的用戶端應用程式需要使用各種不同的索引鍵來取得實體。
- 您的用戶端需要以不同的排序次序來取得實體。
- 您可以使用各種不同的唯一值來識別每個實體。

當您使用不同的 `RowKey` 值來執行實體查閱時，如果您想要避免超出資料分割的擴充性限制，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [最終一致的交易模式](#eventually-consistent-transactions-pattern)  
* [內部資料分割次要索引模式](#intra-partition-secondary-index-pattern)  
* [複合索引鍵模式](#compound-key-pattern)  
* [實體群組交易](#entity-group-transactions)  
* [使用異質性實體類型](#work-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>最終一致的交易模式
使用 Azure 佇列，跨資料分割界限或儲存體系統界限啟用最終一致的行為。  

#### <a name="context-and-problem"></a>內容和問題
EGT 可讓您在共用相的資料分割索引鍵的多個實體之間執行不可部分完成的交易。 基於效能和擴充性的理由，您可能會決定將具有一致性需求的實體儲存在個別的資料分割或個別的儲存系統中。 在這種情況下，您無法使用 Egt 來維持一致性。 例如，您可能必須在下列項目間維護最終一致性：  

* 儲存在相同資料表的兩個不同分割區中、不同的資料表中或不同儲存體帳戶中的實體。  
* 儲存在資料表儲存體中的實體，以及儲存在 Blob 儲存體中的 blob。  
* 儲存在資料表儲存體中的實體，以及檔案系統中的檔案。  
* 儲存在資料表儲存體中，但使用 Azure 認知搜尋進行索引的實體。  

#### <a name="solution"></a>解決方案
藉由使用 Azure 佇列，您可以實作解決方案，提供跨兩個或多個資料分割或儲存系統的最終一致性。

為了說明這種方法，假設您已需要能夠封存先前的員工實體。 先前的員工實體很少查詢，而且應該從任何處理目前員工的活動中排除。 若要執行這項需求，您可以將**目前**資料表中的作用中員工和**封存資料表中的前**一個員工儲存在一起。 封存員工需要您刪除**目前**資料表中的實體，並將實體新增至**封存資料表。**

但是，您無法使用 EGT 來執行這兩項作業。 若要避免因失敗而導致實體同時出現或未出現在這兩個資料表中，封存作業必須最終一致。 下列順序圖說明此作業的步驟。  

![最終一致性的解決方案圖表][12]

用戶端會藉由將訊息放在 Azure 佇列（在此範例中，將員工封存 #456）來起始封存作業。 背景工作角色會輪詢佇列中的新訊息；若找到新訊息，它會讀取訊息，並將隱藏的複本保留在佇列上。 背景工作角色接著會擷取來自**目前**資料表的實體複本、將複本插入**封存**資料表中，然後從**目前**資料表中刪除原始複本。 最後，如果前述步驟沒有任何錯誤，背景工作角色會從佇列中刪除隱藏的訊息。  

在此範例中，圖表中的步驟4會將員工插入**封存資料表。** 它可以將員工新增至 Blob 儲存體中的 blob，或檔案系統中的檔案。  

#### <a name="recover-from-failures"></a>從失敗中復原
如果背景工作角色需要重新開機封存作業，則圖表中步驟4-5 的作業必須是*等冪*。 如果您使用的是資料表儲存體，在步驟4中，您應該使用「插入或取代」作業;在步驟5中，您應該在您所使用的用戶端程式庫中使用「如果存在，則刪除」作業。 如果您使用另一個儲存系統，則必須使用適當的等冪運算。  

如果背景工作角色永遠不會完成圖表中的步驟6，則在超時之後，訊息會重新出現在準備好讓背景工作角色嘗試重新處理的佇列上。 背景工作角色可以檢查佇列上的訊息已被讀取的次數，並在必要時，將其標示為「有害」訊息以供調查，方法是將它傳送至個別的佇列。 如需有關讀取佇列訊息及檢查清除佇列計數的詳細資訊，請參閱[取得訊息](https://msdn.microsoft.com/library/azure/dd179474.aspx)。  

資料表儲存體和佇列儲存體的某些錯誤是暫時性錯誤，而您的用戶端應用程式應包含適當的重試邏輯來處理它們。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 此解決方案不提供交易隔離。 例如，當背景工作角色介於圖表中的步驟4-5 之間時，用戶端可能會讀取**目前** **和封存資料表，並看到**不一致的資料檢視。 資料最終將會一致。  
* 您必須確定步驟4-5 具有等冪性，才能確保最終一致性。  
* 您可以使用多個佇列和背景工作角色執行個體來調整方案。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
如果您想要確保存在於不同磁碟分割或資料表中的實體之間保有最終一致性，請使用此模式。 您可以擴充此模式，以確保跨資料表儲存體和 Blob 儲存體的作業，以及其他非 Azure 儲存體的資料來源（例如資料庫或檔案系統）的最終一致性。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [實體群組交易](#entity-group-transactions)  
* [合併或取代](#merge-or-replace)  

> [!NOTE]
> 如果交易隔離對您的解決方案很重要，請考慮重新設計您的資料表，讓您可以使用 Egt。  
> 
> 

### <a name="index-entities-pattern"></a>索引實體模式
維護索引項目，啟用有效的搜尋以傳回實體清單。  

#### <a name="context-and-problem"></a>內容和問題
資料表儲存體會使用 `PartitionKey` 和 `RowKey` 值，自動編制實體的索引。 這可讓用戶端應用程式使用點查詢有效率地抓取實體。 例如，使用下列資料表結構，用戶端應用程式可以使用部門名稱和員工識別碼（`PartitionKey` 和 `RowKey`）有效率地抓取個別員工實體。  

![Employee 實體的圖形][13]

如果您也想要能夠根據另一個非唯一屬性的值（例如 [姓氏]）來抓取員工實體清單，則必須使用較不有效率的資料分割掃描。 此掃描會尋找相符專案，而不是直接使用索引來查閱它們。 這是因為資料表儲存體不提供次要索引。  

#### <a name="solution"></a>解決方案
若要以前面的實體結構啟用 [依姓氏查閱]，您必須維護員工識別碼的清單。 如果您想要使用特定的姓氏來抓取 employee 實體，例如「表名稱」，您必須先找出具有 [] 姓氏的員工的員工識別碼清單，然後再抓取那些員工實體。 有三個主要選項可儲存員工識別碼的清單：  

* 使用 Blob 儲存體。  
* 在與員工實體相同的磁碟分割中建立索引實體。  
* 在個別的資料分割或資料表中建立索引實體。  

選項1：使用 Blob 儲存體  

為每個唯一的姓氏建立一個 blob，並在每個 blob 中儲存具有該姓氏之員工的 `PartitionKey` （部門）和 `RowKey` （員工識別碼）值的清單。 當您新增或刪除員工時，請確定相關 blob 的內容最終與員工實體一致。  

選項2：在相同的資料分割中建立索引實體  

使用儲存下列資料的索引實體：  

![顯示 employee 實體的圖形，其中包含具有相同姓氏的員工識別碼清單的字串][14]

`EmployeeIDs` 屬性包含姓氏儲存在 `RowKey`中之員工的員工識別碼清單。  

下列步驟概述您在加入新員工時應遵循的程式。 在此範例中，我們要在銷售部門新增識別碼為000152且姓氏為的員工：  

1. 取出具有 `PartitionKey` 值 "Sales" 的索引實體，以及 `RowKey` 值 "（）。 儲存此實體的 ETag　以在步驟 2 中使用。  
2. 建立實體群組交易（也就是批次作業），插入新的員工實體（`PartitionKey` 值 "Sales" 和 `RowKey` 值 "000152"），並更新索引實體（`PartitionKey` 值 "Sales" 和 `RowKey` 值 "，"）。 EGT 會將新的員工識別碼加入至 EmployeeIDs 欄位中的清單來執行這項工作。 如需 Egt 的詳細資訊，請參閱[實體群組交易](#entity-group-transactions)。  
3. 如果 EGT 因為開放式平行存取錯誤而失敗（也就是其他人已修改索引實體），則您必須從步驟1開始。  

如果您使用的是第二個選項，則可以使用類似的方法來刪除員工。 變更員工的姓氏會稍微複雜一點，因為您需要執行更新三個實體的 EGT： employee 實體、舊姓氏的索引實體，以及新姓氏的索引實體。 在進行任何變更之前，您必須先抓取每個實體，才能取得可接著使用開放式平行存取來執行更新的 ETag 值。  

下列步驟概述當您需要查詢部門中具有特定姓氏的所有員工時，應遵循的程式。 在此範例中，我們會查閱銷售部門中姓氏為的所有員工：  

1. 取出具有 `PartitionKey` 值 "Sales" 的索引實體，以及 `RowKey` 值 "（）。  
2. 剖析 [`EmployeeIDs`] 欄位中的員工識別碼清單。  
3. 如果您需要這些員工的詳細資訊（例如其電子郵件地址），請使用 `PartitionKey` 值 "Sales" 來抓取每個員工實體，並從您在步驟2中取得的員工清單中 `RowKey` 值。  

選項3：在個別的資料分割或資料表中建立索引實體  

針對此選項，請使用儲存下列資料的索引實體：  

![顯示 employee 實體的圖形，其中包含具有相同姓氏的員工識別碼清單的字串][15]

`EmployeeIDs` 屬性包含姓氏儲存在 `RowKey`中之員工的員工識別碼清單。  

您無法使用 Egt 來維持一致性，因為索引實體位於與員工實體不同的資料分割中。 確定索引實體最終與員工實體一致。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 此解決方案至少需要兩個查詢來抓取相符的實體：一個用來查詢索引實體以取得 `RowKey` 值的清單，然後查詢以取得清單中的每個實體。  
* 因為個別實體的大小上限為 1 MB，方案中的選項2和選項3會假設任何特定姓氏的員工識別碼清單絕對不會超過 1 MB。 如果員工識別碼的清單大小可能大於 1 MB，請使用選項1，並將索引資料儲存在 Blob 儲存體中。  
* 如果您使用選項2（使用 Egt 來處理新增和刪除員工，以及變更員工的姓氏），您必須評估交易量是否會接近特定分割區中的擴充性限制。 如果是這種情況，您應該考慮最終一致的解決方案（選項1或選項3）。 這些會使用佇列來處理更新要求，並可讓您將索引實體儲存在與員工實體不同的資料分割中。  
* 此解決方案中的選項2假設您想要在部門內依姓氏查閱。 例如，您想要在銷售部門中取出姓氏為的員工清單。 如果您想要能夠在整個組織中查詢姓氏為的所有員工，請使用選項1或選項3。
* 您可以執行以佇列為基礎的解決方案，以提供最終一致性。 如需詳細資訊，請參閱[最終一致的交易模式](#eventually-consistent-transactions-pattern)。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
當您想要查詢一組所有共用通用屬性值的實體（例如，姓氏為的所有員工）時，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [複合索引鍵模式](#compound-key-pattern)  
* [最終一致的交易模式](#eventually-consistent-transactions-pattern)  
* [實體群組交易](#entity-group-transactions)  
* [使用異質性實體類型](#work-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>反正規化模式
將相關資料結合在單一實體中，讓您透過單點查詢擷取所有您所需的資料。  

#### <a name="context-and-problem"></a>內容和問題
在關係資料庫中，您通常會將資料正規化，以移除查詢從多個資料表取得資料時所發生的重複。 如果您將 Azure 資料表中的資料標準化，您必須從用戶端到伺服器往返多次才能擷取相關的資料。 例如，在下表結構中，您需要兩次來回行程來取得部門的詳細資料。 一個行程會提取包含經理識別碼的部門實體，而第二個行程會在 employee 實體中提取經理的詳細資料。  

![部門實體和員工實體的圖形][16]

#### <a name="solution"></a>解決方案
不要將資料儲存在兩個不同的實體中，而是將資料反正規化，並將管理員詳細資料的複本保存在部門實體中。 例如：  

![反正規化和合併部門實體的圖形][17]

使用這些屬性來儲存部門實體時，您現在可以使用點查詢來抓取有關部門的所有詳細資料。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 儲存資料兩次還有一些相關的成本負擔。 較少對資料表儲存體的要求所產生的效能優點，通常會高於儲存體成本的臨界增加。 此外，這項成本的部分位移，是藉由減少提取部門詳細資料所需的交易數目。  
* 您必須讓儲存管理員相關資訊的兩個實體保有一致性。 您可以使用 Egt 在單一不可部分完成的交易中更新多個實體，以處理一致性問題。 在此情況下，部門經理的「部門」實體和「員工」實體會儲存在相同的資料分割中。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
如果您經常需要查閱相關資訊，請使用此模式。 此模式可減少用戶端在擷取其所需資料時必須執行的查詢數目。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [複合索引鍵模式](#compound-key-pattern)  
* [實體群組交易](#entity-group-transactions)  
* [使用異質性實體類型](#work-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>複合索引鍵模式
使用複合 `RowKey` 值，讓用戶端使用單點查詢來查閱相關資料。  

#### <a name="context-and-problem"></a>內容和問題
在關係資料庫中，在查詢中使用聯結，以在單一查詢中將相關的資料片段傳回至用戶端，是很自然的。 例如，您可以使用員工識別碼來查閱包含該員工之績效和考核資料的相關實體清單。  

假設您使用下列結構，將員工實體儲存在資料表儲存體中：  

![Employee 實體的圖形][18]

您也需要儲存與員工在貴組織中的每一年的評論和效能相關的歷程記錄資料，而且您必須能夠依年度存取這項資訊。 建立另一個資料表來儲存具有下列結構的實體，是可行選項之一：  

![員工評論實體的圖形][19]

使用此方法時，您可能會決定複製新實體中的某些資訊（例如名字和姓氏），讓您使用單一要求來抓取您的資料。 不過，您無法維持強式一致性，因為您無法使用 EGT 來以原子方式更新這兩個實體。  

#### <a name="solution"></a>解決方案
使用具有下列結構的實體，在原始資料表中儲存新的實體類型：  

![具有複合索引鍵之 employee 實體的圖形][20]

請注意，`RowKey` 現在是複合索引鍵，由員工識別碼和考核資料年份所組成。 這可讓您使用單一實體的單一要求來抓取員工的效能和審核資料。  

下列範例說明如何擷取特定員工的所有考核資料 (例如銷售部門的員工 000123)：  

$filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000123') and (RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 您應該使用適當的分隔符號，輕鬆地剖析 `RowKey` 的值：例如**000123_2012**。  
* 您也會將此實體儲存在與其他包含相同員工相關資料的實體相同的分割區中。 這表示您可以使用 Egt 來維持強式一致性。
* 您應該考慮查詢資料的頻率，以判斷此模式是否合適。 例如，如果您不常存取審核資料，而且經常需要主要員工資料，您應該將它們保留為個別的實體。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
如果您需要儲存一或多個您經常查詢的相關實體，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [實體群組交易](#entity-group-transactions)  
* [使用異質性實體類型](#work-with-heterogeneous-entity-types)  
* [最終一致的交易模式](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>記錄結尾模式
使用以反向的日期和時間順序排序的 `RowKey` 值，取出最近新增至資料分割的*n*個實體。  

> [!NOTE]
> Azure 資料表 API 在 Azure Cosmos DB 中傳回的查詢結果不會依資料分割索引鍵或資料列索引鍵排序。 因此，雖然此模式適用于資料表儲存體，但它不適用於 Azure Cosmos DB。 如需詳細的功能差異清單，請參閱 [Azure Cosmos DB 和 Azure 資料表儲存體中資料表 API 之間的差異](faq.md#where-is-table-api-not-identical-with-azure-table-storage-behavior)。

#### <a name="context-and-problem"></a>內容和問題
常見的需求是要能夠取出最近建立的實體，例如員工提交的最近 10 筆費用請款。 資料表查詢支援 `$top` 查詢作業，以從集合中傳回前*n*個實體。 沒有對等的查詢作業可傳回集合中的最後*n*個實體。  

#### <a name="solution"></a>解決方案
使用自然以反向的日期/時間順序排序的 `RowKey` 來儲存實體，因此最新的專案一律是資料表中的第一個。  

比方說，若要能夠擷取某員工最近提交的十筆費用請款，您可以使用衍生自目前日期/時間的反向刻度值。 下列C#程式碼範例示範一種方法，為從最新到最舊的 `RowKey`，建立適當的「反向刻度」值：  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

您可以使用下列程式碼回到日期/時間值：  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

資料表查詢如下所示：  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 您必須以前置零填補反向刻度值，以確保字串值如預期般排序。  
* 您必須知道資料分割層級的延展性目標。 請小心不要建立作用點磁碟分割。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
當您需要以反向的日期/時間順序存取實體，或當您需要存取最近新增的實體時，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [在前面加上/附加反向模式](#prepend-append-anti-pattern)  
* [取出實體](#retrieve-entities)  

### <a name="high-volume-delete-pattern"></a>大量刪除模式
將所有要同時刪除的實體儲存在自己的個別資料表中，以啟用刪除大量實體的功能。 您可以藉由刪除資料表來刪除實體。  

#### <a name="context-and-problem"></a>內容和問題
許多應用程式刪除用戶端應用程式已無需使用的舊資料，或應用程式已封存至其他儲存媒體的舊資料。 您通常會依日期來識別這類資料。 例如，您必須刪除超過60天以前的所有登入要求記錄。  

其中一個可能的設計是在 `RowKey`中使用登入要求的日期和時間：  

![登入嘗試實體的圖形][21]

這種方法可避免資料分割熱點，因為應用程式可以在個別的資料分割中插入和刪除每個使用者的登入實體。 不過，如果您有大量實體，這種方法可能會相當耗費成本且耗時。 首先，您需要執行資料表掃描以識別要刪除的所有實體，然後您必須刪除每個舊的實體。 您可以藉由將多個刪除要求批次處理到 EGT 中，以減少刪除舊實體所需的伺服器往返次數。  

#### <a name="solution"></a>解決方案
為每天的登入嘗試使用個別的資料表。 當您要插入實體時，可以使用上述實體設計來避免作用區。 刪除舊實體現在只是每天刪除一個資料表（單一儲存體作業）的問題，而不是每天尋找及刪除上百個或數千個個別登入實體。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 您的設計是否支援應用程式將使用資料的其他方式，例如查閱特定實體、與其他資料連結，或產生匯總資訊？  
* 您的設計在插入新實體時是否可避免產生熱點？  
* 如果您在刪除某個資料表名稱後想要加以重複使用，預期應會有延遲。 最好是一律使用唯一的資料表名稱。  
* 當您第一次使用新的資料表時，預期會有一些速率限制，而資料表儲存體則會學習存取模式，並將資料分割分散到各個節點。 您應考量您需要建立新資料表的頻率。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
如果您有大量的實體必須同時刪除，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [實體群組交易](#entity-group-transactions)
* [修改實體](#modify-entities)  

### <a name="data-series-pattern"></a>資料序列模式
將完整資料序列儲存在單一實體中，以盡可能減少您提出的要求數。  

#### <a name="context-and-problem"></a>內容和問題
常見的案例是應用程式需一次儲存必須經常擷取的資料序列。 比方說，您的應用程式可能會記錄每一位員工每小時傳送多少 IM 訊息，然後使用這項資訊來繪製每個使用者在過去 24 小時內傳送的訊息數。 一個設計可為每個員工儲存 24 個實體：  

![訊息統計資料實體的圖形][22]

採用這種設計，您可以輕鬆地找出並更新實體，以在應用程式需要更新訊息計數值時更新每個員工。 不過，若要擷取資訊以繪製過去 24 小時內的活動圖，您必須擷取 24 個實體。  

#### <a name="solution"></a>解決方案
使用下列設計，搭配個別的屬性來儲存每小時的訊息計數：  

![顯示具有分隔屬性之訊息統計資料實體的圖形][23]

透過這項設計，您可以使用合併作業來更新員工在特定時段內的訊息計數。 現在，您可以使用單一實體的要求，抓取繪製圖表所需的所有資訊。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 如果您的完整資料數列無法納入單一實體（實體最多可以有252屬性），請使用替代的資料存放區（例如 blob）。  
* 如果您有多個用戶端同時更新實體，請使用**ETag**來執行開放式平行存取。 如果您有許多用戶端，可能會遇到高度爭用的情況。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
如果您需要更新和擷取與個別實體相關聯的資料序列，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [大型實體模式](#large-entities-pattern)  
* [合併或取代](#merge-or-replace)  
* [最終一致的交易模式](#eventually-consistent-transactions-pattern)（如果您要將資料數列儲存在 blob 中）  

### <a name="wide-entities-pattern"></a>寬型實體模式
使用多個實際的實體來儲存具有超過 252 個屬性的邏輯實體。  

#### <a name="context-and-problem"></a>內容和問題
個別實體可以有252個以上的屬性（不包括必要的系統屬性），而且無法儲存總共超過 1 MB 的資料。 在關係資料庫中，您通常會藉由加入新的資料表，並在兩者之間強制執行一對一的關聯性，來解決資料列大小的任何限制。  

#### <a name="solution"></a>解決方案
藉由使用資料表儲存體，您可以儲存多個實體來代表具有超過252個屬性的單一大型商務物件。 例如，如果您想要儲存每位員工在過去365天傳送的 IM 訊息數目，您可以使用下列設計來使用具有不同架構的兩個實體：  

![圖形：顯示具有 Rowkey 01 的訊息統計資料實體與 Rowkey 02 的訊息統計資料實體][24]

如果您需要進行必須同時更新兩個實體的變更，讓它們彼此保持同步，您可以使用 EGT。 否則，您可以使用合併作業來更新某天的訊息計數。 若要取得個別員工的所有資料，您必須同時取得這兩個實體。 您可以透過兩個同時使用 `PartitionKey` 和 `RowKey` 值的有效率要求來執行這項操作。  

#### <a name="issues-and-considerations"></a>問題和考量
在決定如何執行此模式時，請考慮下列重點：  

* 擷取完成邏輯實體牽涉到至少兩個儲存體交易：一個用來擷取每個實際的實體。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
當您需要儲存屬性的大小或數目超過資料表儲存體中個別實體限制的實體時，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [實體群組交易](#entity-group-transactions)
* [合併或取代](#merge-or-replace)

### <a name="large-entities-pattern"></a>大型實體模式
使用 Blob 儲存體來儲存大型屬性值。  

#### <a name="context-and-problem"></a>內容和問題
個別實體無法儲存總計超過 1 MB 的資料。 如果其中一個或多個屬性儲存的值導致實體的總大小超過此值，您就無法將整個實體儲存在資料表儲存體中。  

#### <a name="solution"></a>解決方案
如果您的實體大小超過 1 MB，因為一個或多個屬性包含大量資料，您可以將資料儲存在 Blob 儲存體中，然後將該 blob 的位址儲存在實體的屬性中。 例如，您可以將員工的相片儲存在 Blob 儲存體中，並在 employee 實體的 `Photo` 屬性中儲存相片的連結：  

![顯示員工實體的圖形，其中包含指向 Blob 儲存體的相片字串][25]

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 若要維持資料表儲存體中的實體與 Blob 儲存體中的資料之間的最終一致性，請使用[最終一致的交易模式](#eventually-consistent-transactions-pattern)來維護您的實體。
* 擷取完整實體牽涉到至少兩個儲存體交易：一個用來擷取實體，另一個擷取 Blob 資料。  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
當您需要儲存其大小超過資料表儲存體中個別實體限制的實體時，請使用此模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [最終一致的交易模式](#eventually-consistent-transactions-pattern)  
* [寬型實體模式](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>在前面加上/附加反向模式
當您有大量的插入時，請將插入分散到多個分割區，以增加擴充性。  

#### <a name="context-and-problem"></a>內容和問題
在前面加上或附加實體至您已儲存的實體，通常會導致應用程式將新實體新增至資料分割序列的第一個或最後一個資料分割。 在此情況下，任何特定時間的所有插入都是在相同的分割區中進行，並建立一個熱點。 這可避免資料表儲存體將插入負載平衡到多個節點，而且可能會導致您的應用程式達到資料分割的擴充性目標。 例如，假設有一個應用程式會記錄員工的網路和資源存取。 如果交易量到達個別資料分割的擴充性目標，則如下的實體結構可能會導致目前小時的資料分割成為熱點：  

![Employee 實體的圖形][26]

#### <a name="solution"></a>解決方案
下列替代實體結構可避免任何特定資料分割上的熱點，因為應用程式會記錄事件：  

![顯示員工實體的圖形，其中包含年、月、日、小時和事件識別碼的 RowKey 複利][27]

請注意，在此範例中，`PartitionKey` 和 `RowKey` 都是複合索引鍵。 `PartitionKey` 會同時使用部門和員工識別碼將記錄散發到多個資料分割。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何實作此模式時，請考慮下列幾點：  

* 可避免在插入時產生熱點資料分割的替代索引鍵結構，是否可有效支援用戶端應用程式發出的查詢？  
* 您預期的交易量是否表示您可能會達到個別資料分割的擴充性目標，並受到資料表儲存體的節流？  

#### <a name="when-to-use-this-pattern"></a>使用此模式的時機
當您存取熱資料分割時，如果您的交易量可能會導致資料表儲存體的速率限制，請避免在前面加上/附加反向模式。  

#### <a name="related-patterns-and-guidance"></a>相關的模式和指導方針
實作此模式時，下列模式和指導方針可能也相關：  

* [複合索引鍵模式](#compound-key-pattern)  
* [記錄檔結尾模式](#log-tail-pattern)  
* [修改實體](#modify-entities)  

### <a name="log-data-anti-pattern"></a>記錄資料反向模式
一般而言，您應該使用 Blob 儲存體，而不是資料表儲存體來儲存記錄資料。  

#### <a name="context-and-problem"></a>內容和問題
記錄資料的常見使用案例是針對特定日期/時間範圍，抓取記錄專案的選擇。 例如，您想要尋找應用程式在特定日期的15:04 和15:06 記錄的所有錯誤和重大訊息。 您不想要使用記錄訊息的日期和時間來判斷儲存記錄實體的資料分割。 這會導致熱分割，因為在任何特定時間，所有的記錄實體都會共用相同的 `PartitionKey` 值（請參閱[前面加上/附加反向模式](#prepend-append-anti-pattern)）。 例如，記錄訊息的下列實體架構會產生熱資料分割，因為應用程式會將所有記錄訊息寫入目前日期和小時的分割區：  

![記錄訊息實體的圖形][28]

在此範例中，`RowKey` 包含記錄訊息的日期和時間，以確保記錄檔訊息會以日期/時間順序排序。 如果多個記錄訊息共用相同的日期和時間，`RowKey` 也會包含訊息識別碼。  

另一種方法是使用 `PartitionKey`，以確保應用程式會在一系列的資料分割中寫入訊息。 例如，如果記錄訊息的來源提供將訊息分散到多個分割區的方式，您可以使用下列實體架構：  

![記錄訊息實體的圖形][29]

不過，此架構的問題在於，若要取得特定時間範圍內的所有記錄檔訊息，您必須搜尋資料表中的每個資料分割。

#### <a name="solution"></a>解決方案
上一節強調了嘗試使用表格儲存體來儲存記錄專案的問題，並建議兩個不滿意的設計。 其中一個解決方案會導致最忙碌的資料分割，並具有效能不佳的寫入記錄訊息的風險。 另一個解決方案導致查詢效能不佳，因為需要掃描資料表中的每個資料分割，以取得特定時間範圍的記錄訊息。 Blob 儲存體為此類案例提供更好的解決方案，而這就是 Azure 儲存體分析如何儲存它所收集的記錄資料。  

本節概述儲存體分析如何將記錄資料儲存在 Blob 儲存體中，以這種方式來儲存您通常依範圍查詢的資料。  

儲存體分析會將記錄訊息以分隔格式儲存在多個 blob 中。 分隔格式可方便用戶端應用程式剖析記錄訊息中的資料。  

儲存體分析會針對 blob 使用命名慣例，讓您找出包含您要搜尋之記錄訊息的 blob （或 blob）。 例如，名為 "queue/2014/07/31/1800/000001" 的 blob 包含從2014年7月31日18:00 開始，一小時內與佇列服務相關的記錄訊息。 "000001"表示這是這段期間的第一個記錄檔。 儲存體分析也會記錄儲存在檔案中的第一個和最後一個記錄訊息的時間戳記，做為 blob 中繼資料的一部分。 適用于 Blob 儲存體的 API 可讓您根據名稱前置詞，找出容器中的 blob。 若要從18:00 開始找出一小時內包含佇列記錄資料的所有 blob，您可以使用前置詞 "queue/2014/07/31/1800"。  

儲存體分析會在內部緩衝處理記錄訊息，然後定期更新適當的 blob，或使用最新批次的記錄檔專案來建立新的 blob。 這會減少它必須對 Blob 儲存體執行的寫入次數。  

如果您要在自己的應用程式中執行類似的解決方案，請考慮如何管理可靠性和成本與擴充性之間的取捨。 換句話說，評估在 Blob 儲存體中寫入每個記錄專案的效果，相較于在應用程式中緩衝更新，並以批次方式將它們寫入 Blob 儲存體。  

#### <a name="issues-and-considerations"></a>問題和考量
當您決定如何儲存記錄資料時，請考慮下列幾點：  

* 如果您建立的資料表設計會避免可能的熱資料分割，您可能會發現您無法有效率地存取記錄資料。  
* 在處理記錄資料時，用戶端常需要載入多筆記錄。  
* 雖然記錄資料通常是結構化的，但 Blob 儲存體可能是較佳的解決方案。  

### <a name="implementation-considerations"></a>實作考量
本節討論您在實作前面幾節說明的模式時應謹記在心的注意事項。 本節中的範例大多是以 C# 撰寫，並使用儲存體用戶端程式庫 (撰寫本文時為 4.3.0 版)。  

### <a name="retrieve-entities"></a>取出實體
如 [查詢的設計](#design-for-querying)一節中所述，最有效率的查詢是點查詢。 不過，在某些情況下，您可能需要取出多個實體。 本節說明使用儲存體用戶端程式庫來抓取實體的一些常見方法。  

#### <a name="run-a-point-query-by-using-the-storage-client-library"></a>使用儲存體用戶端程式庫執行點查詢
執行 point 查詢最簡單的方式是使用「**取出**資料表」作業。 如下列C#程式碼片段所示，這項作業會抓取 `PartitionKey` 值為 "Sales" 的實體，以及值為 "212" 的 `RowKey`：  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

請注意，此範例會預期它所抓取的實體是 `EmployeeEntity`的型別。  

#### <a name="retrieve-multiple-entities-by-using-linq"></a>使用 LINQ 取出多個實體
您可以搭配使用 LINQ 與儲存體用戶端程式庫，並指定具有**where**子句的查詢，來抓取多個實體。 若要避免資料表掃描，您應一律在 where 子句中包含 `PartitionKey` 值，並在可能的情況下，`RowKey` 值以避免資料表和資料分割掃描。 資料表儲存體支援在 where 子句中使用的一組有限的比較運算子（大於、大於或等於、小於、小於或等於、等於和不等於）。 下列C#程式碼片段會尋找姓氏以 "B" 開頭的所有員工（假設 `RowKey` 將姓氏儲存在銷售部門中）（假設 `PartitionKey` 儲存部門名稱）：  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

請注意查詢如何同時指定 `RowKey` 和 `PartitionKey`，以確保效能更佳。  

下列程式碼範例使用 Fluent API 顯示對等的功能（如需有關流暢 Api 的詳細資訊，請參閱[設計 Fluent API 的最佳做法](https://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)）：  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> 此範例會嵌套多個 `CombineFilters` 方法，以包含三個篩選準則。  
> 
> 

#### <a name="retrieve-large-numbers-of-entities-from-a-query"></a>從查詢中取出大量實體
最佳查詢會根據 `PartitionKey` 值和 `RowKey` 值來傳回個別實體。 不過，在某些情況下，您可能需要從相同的分割區中傳回多個實體，或甚至是從多個磁碟分割傳回。 在此類情況下，您務必要完整測試應用程式的效能。  

針對資料表儲存體的查詢最多可傳回1000個實體一次，並執行最多五秒。 資料表儲存體會傳回接續 token，讓用戶端應用程式可以要求下一組實體（如果下列任一條件成立）：

- 結果集包含超過1000個實體。
- 查詢未于五秒內完成。
- 查詢會跨越資料分割界限。 

如需接續權杖如何工作的詳細資訊，請參閱[查詢超時和分頁](https://msdn.microsoft.com/library/azure/dd135718.aspx)。  

如果您使用儲存體用戶端程式庫，它可以在從資料表儲存體傳回實體時，自動為您處理接續權杖。 例如，下列C#程式碼範例會在資料表儲存體于回應中傳回接續 token 時自動加以處理：  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

下列 C# 程式碼會明確處理接續權杖：  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

藉由明確使用接續權杖，您將可控制應用程式何時會擷取下一個資料區段。 例如，如果您的用戶端應用程式可讓使用者逐頁流覽儲存在資料表中的實體，使用者可能會決定不要逐頁流覽查詢所抓取的所有實體。 當使用者完成目前區段中所有實體的分頁時，您的應用程式只會使用接續 token 來抓取下一個區段。 這種方法有幾項優點：  

* 您可以限制從資料表儲存體抓取的資料量，以及透過網路移動的資料量。  
* 您可以在 .NET 中執行非同步 i/o。  
* 您可以將接續 token 序列化為持續性儲存體，以便在發生應用程式當機時繼續進行。  

> [!NOTE]
> 接續 token 通常會傳回包含1000實體的區段，雖然它可以包含較少的專案。 如果您使用**Take**傳回符合查閱準則的前 n 個實體來限制查詢所傳回的專案數，也會發生這種情況。 資料表儲存體可能會傳回包含少於 n 個實體的區段以及接續權杖，讓您能夠抓取其餘的實體。  
> 
> 

下列 C# 程式碼說明如何修改區段內傳回的實體數目：  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>伺服器端預測
單一實體最多可以有 255 個屬性，且大小上限為 1 MB。 當您查詢資料表並抓取實體時，您可能不需要所有屬性，而且可以避免不必要地傳輸資料（以協助降低延遲和成本）。 您可以使用伺服器端預測，僅傳送您需要的屬性。 下列範例只會從查詢所選取的實體中，抓取 `Email` 屬性（連同 `PartitionKey`、`RowKey`、`Timestamp`和 `ETag`）。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

請注意，即使未包含在要抓取的屬性清單中，也可以使用 `RowKey` 值。  

### <a name="modify-entities"></a>修改實體
儲存體用戶端程式庫可讓您藉由插入、刪除和更新實體，來修改儲存在資料表儲存體中的實體。 您可以使用 Egt 將多個插入、更新和刪除作業一起批次處理，以減少所需的往返次數，並提升解決方案的效能。  

當儲存體用戶端程式庫執行 EGT 時所擲回的例外狀況，通常包含導致批次失敗之實體的索引。 當您偵錯使用 EGT 的程式碼時，這會很有幫助。  

您也應該考量您的設計會如何影響用戶端應用程式處理並行存取和更新作業的方式。  

#### <a name="managing-concurrency"></a>管理並行存取
根據預設，資料表儲存體會在個別實體的層級上，針對插入、合併和刪除作業執行開放式平行存取檢查，雖然用戶端可以強制資料表儲存體略過這些檢查。 如需詳細資訊，請參閱[管理 Microsoft Azure 儲存體中的並行](../storage/common/storage-concurrency.md)存取。  

#### <a name="merge-or-replace"></a>合併或取代
`TableOperation` 類別的 `Replace` 方法一律會取代資料表儲存體中的完整實體。 如果在已儲存的實體中存在該屬性時，要求中未包含屬性，要求就會從儲存的實體中移除該屬性。 除非您想要明確地從已儲存的實體中移除屬性，否則即必須在要求中包含每個屬性。  

當您想要更新實體時，您可以使用 `TableOperation` 類別的 `Merge` 方法，減少傳送到資料表儲存體的資料量。 `Merge` 方法會將已儲存實體中的任何屬性取代為要求中包含之實體的屬性值。 這個方法會在未包含在要求中的預存實體中，保留不變的任何屬性。 如果您有大型實體，而且只需要在要求中更新少量的屬性，這就很有用。  

> [!NOTE]
> 如果實體不存在，`*Replace` 和 `Merge` 方法會失敗。 或者，您可以使用 `InsertOrReplace` 和 `InsertOrMerge` 方法來建立新的實體（如果不存在）。  
> 
> 

### <a name="work-with-heterogeneous-entity-types"></a>使用異類實體類型
資料表儲存體是不限*架構*的資料表存放區。 這表示單一資料表可以儲存多種類型的實體，並在您的設計中提供絕佳的彈性。 下列範例說明用以儲存員工和部門實體的資料表：  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>時間戳記</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

每個實體仍然必須有 `PartitionKey`、`RowKey`和 `Timestamp` 值，但可以有任何一組屬性。 此外，除非您選擇將該資訊儲存在某處，否則沒有任何專案可指出實體的類型。 有兩個選項可用來識別實體類型：  

* 在 `RowKey` 前面加上實體類型（或可能是 `PartitionKey`）。 例如，`EMPLOYEE_000123` 或 `DEPARTMENT_SALES` 做為 `RowKey` 值。  
* 使用不同的屬性來記錄實體類型，如下表所示。  

<table>
<tr>
<th>PartitionKey</th>
<th>RowKey</th>
<th>時間戳記</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>員工</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>員工</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>department</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>名字</th>
<th>姓氏</th>
<th>年齡</th>
<th>電子郵件</th>
</tr>
<tr>
<td>員工</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

第一個選項（在 `RowKey`前面加上實體類型）在可能有兩個不同類型的實體具有相同的索引鍵值時，會很有用。 它也會將屬於相同類型的實體分組在資料分割中。  

本節中所討論的技巧與[繼承關係](#inheritance-relationships)的討論特別相關。  

> [!NOTE]
> 請考慮在實體類型值中包含版本號碼，讓用戶端應用程式能夠進化 POCO 物件，並使用不同的版本。  
> 
> 

本節的其餘部分說明儲存體用戶端程式庫中一些有助於在相同資料表中使用多個實體類型的功能。  

#### <a name="retrieve-heterogeneous-entity-types"></a>取出異類實體類型
如果您使用的是儲存體用戶端程式庫，則有三個選項可使用多個實體類型。  

如果您知道以特定 `RowKey` 和 `PartitionKey` 值儲存的實體類型，則可以在取得實體時指定實體類型。 您在先前的兩個範例中看到這種情況，會抓取 `EmployeeEntity`類型的實體：[使用儲存體用戶端程式庫執行點查詢](#run-a-point-query-by-using-the-storage-client-library)，並[使用 LINQ 抓取多個實體](#retrieve-multiple-entities-by-using-linq)。  

第二個選項是使用 `DynamicTableEntity` 類型（屬性包），而不是具體的 POCO 實體類型。 此選項也可能會改善效能，因為不需要將實體序列化和還原序列化成 .NET 類型。 下列C#程式碼可能會從資料表中抓取不同類型的多個實體，但會以 `DynamicTableEntity` 實例的形式傳回所有實體。 然後，它會使用 `EntityType` 屬性來判斷每個實體的類型：  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

若要取得其他屬性，您必須在 `DynamicTableEntity` 類別的 `Properties` 屬性上使用 `TryGetValue` 方法。  

第三個選項是使用 `DynamicTableEntity` 類型和 `EntityResolver` 實例進行結合。 這可讓您解析為相同查詢中的多個 POCO 類型。 在此範例中，`EntityResolver` 委派會使用 `EntityType` 屬性來區分查詢所傳回的兩個實體類型。 `Resolve` 方法會使用 `resolver` 委派，將 `DynamicTableEntity` 實例解析為 `TableEntity` 實例。  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modify-heterogeneous-entity-types"></a>修改異類實體類型
您不需要知道實體的類型即可將它刪除，而且當您插入實體時，一律會知道其類型。 不過，您可以使用 `DynamicTableEntity` 類型來更新實體，而不需要知道其類型，也不需要使用 POCO 實體類別。 下列程式碼範例會抓取單一實體，並檢查 `EmployeeCount` 屬性是否存在，然後再進行更新。  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="control-access-with-shared-access-signatures"></a>使用共用存取簽章控制存取
您可以使用共用存取簽章（SAS）權杖，讓用戶端應用程式直接修改（和查詢）資料表實體，而不需要直接使用資料表儲存體進行驗證。 一般而言，在您的應用程式中使用 SAS 有三大優點：  

* 您不需要將儲存體帳戶金鑰散發到不安全的平臺（例如行動裝置），即可讓該裝置存取和修改資料表儲存體中的實體。  
* 您可以卸載一些 web 和背景工作角色在管理您的實體時所執行的工作。 您可以卸載至用戶端裝置，例如終端使用者電腦和行動裝置。  
* 您可以為用戶端指派受限制和限時的許可權集（例如允許特定資源的唯讀存取）。  

如需搭配使用 SAS 權杖與資料表儲存體的詳細資訊，請參閱[使用共用存取簽章（SAS）](../storage/common/storage-dotnet-shared-access-signature-part-1.md)。  

不過，您仍然必須產生 SAS 權杖，以將用戶端應用程式授與資料表儲存體中的實體。 在可安全存取儲存體帳戶金鑰的環境中執行此動作。 一般而言，您可以使用 Web 或背景工作角色來產生 SAS 權杖，並將其傳送至需要存取您的實體的用戶端應用程式。 由於產生 SAS 權杖並將其傳遞至用戶端仍會產生額外負荷，因此您應考量怎樣最能降低此負荷，尤其是在大量的案例中。  

您可以產生 SAS 權杖，以授與資料表中實體子集的存取權。 根據預設，您會建立整個資料表的 SAS 權杖。 但也可以指定 SAS 權杖授與 `PartitionKey` 值範圍的存取權，或某個範圍的 `PartitionKey` 和 `RowKey` 值。 您可以選擇為系統的個別使用者產生 SAS 權杖，讓每個使用者的 SAS 權杖只允許他們在資料表儲存體中存取自己的實體。  

### <a name="asynchronous-and-parallel-operations"></a>非同步和平行作業
假設您要跨多個資料分割分散您的要求，您可以使用非同步或平行查詢來改善輸送量和用戶端的回應性。
例如，您可以用兩個或更多背景工作角色執行個體，以平行方式存取您的資料表。 您可以讓個別背景工作角色負責特定的資料分割集，或只擁有多個背景工作角色實例，每個都能夠存取資料表中的所有資料分割。  

在用戶端實例內，您可以非同步執行儲存體作業來改善輸送量。 儲存體用戶端程式庫可讓您輕鬆撰寫非同步查詢並修改。 例如，您可能會從抓取資料分割中所有實體的同步方法開始著手，如下列C#程式碼所示：  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

您可以輕鬆地修改此程式碼，讓查詢以非同步方式執行，如下所示：  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

在此非同步範例中，您可以看到下列與同步版本不同的變更：  

* 方法簽章現在包含 `async` 修飾詞，並會傳回 `Task` 實例。  
* 方法現在會呼叫 `ExecuteSegmentedAsync` 方法，而不是呼叫 `ExecuteSegmented` 方法來取得結果。 方法會使用 `await` 修飾詞，以非同步方式取得結果。  

用戶端應用程式可以多次呼叫此方法，`department` 參數的值不同。 每個查詢都會在不同的執行緒上執行。  

`TableQuery` 類別中沒有 `Execute` 方法的非同步版本，因為 `IEnumerable` 介面不支援非同步列舉。  

您也可以透過非同步方式插入、更新和刪除實體。 下列 C# 範例說明如何以簡單的同步方法來插入或取代員工實體：  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

您可以輕鬆地修改此程式碼，讓更新以非同步方式執行，如下所示：  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

在此非同步範例中，您可以看到下列與同步版本不同的變更：  

* 方法簽章現在包含 `async` 修飾詞，並會傳回 `Task` 實例。  
* 方法現在會呼叫 `ExecuteAsync` 方法，而不是呼叫 `Execute` 方法來更新實體。 方法會使用 `await` 修飾詞，以非同步方式取得結果。  

用戶端應用程式可以呼叫多個非同步方法（例如這一個），而每個方法調用都會在個別的執行緒上執行。  


[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

